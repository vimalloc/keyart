#!/usr/bin/env python

import argparse
import os
import re   # needed only for work around
import subprocess
import sys

parser = argparse.ArgumentParser(description='Create an ASCII art of a PGP key.')
parser.add_argument('-a','--ansi', help='Print the art with ANSI color.',
    action='store_true')
parser.add_argument('file', type=argparse.FileType('r'))
args = parser.parse_args()

def draw_art(keyfile):
    try:
        if os.access('/usr/bin/gpg',os.X_OK):
            gpg_bin = '/usr/bin/gpg'
        else:
            gpg_bin = '/usr/bin/gpg2'

        DEVNULL = open(os.devnull, 'wb')
        gpg = subprocess.Popen(
            (gpg_bin,'--with-fingerprint','--with-colons', keyfile),
            stdout=subprocess.PIPE, stderr=DEVNULL)
        out = gpg.communicate()
        DEVNULL.close()
    except OSError:
        print "Please install GnuPG before using this script."
        sys.exit(4)

    try:
        key_size = [i.strip() for i in out[0].split(':')][2]
        key_algo = [i.strip() for i in out[0].split(':')][3]
        key_fpr = [i.strip() for i in out[0].split(':')][19]

        ### BEGIN ugly work around for GnuPG bug #1640
        # See: https://bugs.g10code.com/gnupg/issue1640
        pattern = re.compile('[A-Z0-9]{40}')

        if not pattern.match(key_fpr):
            DEVNULL = open(os.devnull, 'wb')
            gpg = subprocess.Popen((gpg_bin,'--import',keyfile), stderr=DEVNULL)
            out = gpg.communicate()
            gpg = subprocess.Popen(
                (gpg_bin,'--fingerprint','--with-colons',os.path.splitext(keyfile)[0]),
                stdout=subprocess.PIPE)
            out = gpg.communicate()
            DEVNULL.close()
            key_fpr = [i.strip() for i in out[0].split(':')][28]
        ### END ugly work around

    except IndexError:
        print "It appears that {0} is not an exported public PGP key.".format(keyfile)
        sys.exit(5)

    coin = ''
    art = ''
    f_bytes = []
    pos = 104
    walk = [pos]
    visits = [0]*209
    if args.ansi:
        b1 = '\033[38;5;21m' # blue
        b2 = '\033[38;5;33m'
        b3 = '\033[38;5;45m'
        b4 = '\033[38;5;50m'
        g1 = '\033[38;5;48m'
        g2 = '\033[38;5;46m' # green
        g3 = '\033[38;5;118m'
        y1 = '\033[38;5;190m'
        y2 = '\033[38;5;226m' # yellow
        y3 = '\033[38;5;220m'
        o1 = '\033[38;5;214m' # orange
        o2 = '\033[38;5;208m'
        o3 = '\033[38;5;202m'
        r1 = '\033[38;5;196m' # red
        r2 = '\033[38;5;203m'
        r3 = '\033[38;5;210m'
        p1 = '\033[38;5;217m' # pink
        p2 = '\033[38;5;224m'
        reset = '\033[0m'

        coins = [' ', '%s%s%s' % (b1,'.',reset), '%s%s%s' % (b2,'^',reset),
                      '%s%s%s' % (b3,':',reset), '%s%s%s' % (b4,'l',reset),
                      '%s%s%s' % (g1,'i',reset), '%s%s%s' % (g2,'?',reset),
                      '%s%s%s' % (g3,'{',reset), '%s%s%s' % (y1,'f',reset),
                      '%s%s%s' % (y2,'x',reset), '%s%s%s' % (y3,'X',reset),
                      '%s%s%s' % (o1,'Z',reset), '%s%s%s' % (o2,'#',reset),
                      '%s%s%s' % (o3,'M',reset), '%s%s%s' % (r1,'W',reset),
                      '%s%s%s' % (r2,'&',reset), '%s%s%s' % (r3,'8',reset),
                      '%s%s%s' % (p1,'%',reset), '%s%s%s' % (p2,'@',reset)]
        markers = ['%s%s' % (reset,'S'), '%s%s' % (reset,'E')]
    else:
        coins = [' ','.','^',':','l','i','?','{','f','x','X','Z','#','M','W','&','8','%','@']

    zfill = str.zfill

    for c in key_fpr:
        f_bytes.append(zfill(bin(int(c,16))[2:],4)[:2]) # last 2 bits
        f_bytes.append(zfill(bin(int(c,16))[2:],4)[2:]) # first 2 bits

    for d in f_bytes:
        if (20 <= pos <=  36 or  39 <= pos <=  55 or  58 <= pos <=  74 or
            77 <= pos <=  93 or  96 <= pos <= 112 or 115 <= pos <= 131 or
           134 <= pos <= 150 or 153 <= pos <= 169 or 172 <= pos <= 188):
            if   d == '00': pos -= 20 # Square 'M'
            elif d == '01': pos -= 18
            elif d == '10': pos += 18
            else: pos += 20
        elif 1 <= pos <= 17: # Square 'T'
            if   d == '00': pos -= 1
            elif d == '01': pos += 1
            elif d == '10': pos += 18
            else: pos += 20
        elif 191 <= pos <= 207: # Square 'B'
            if   d == '00': pos -= 20
            elif d == '01': pos -= 18
            elif d == '10': pos -= 1
            else: pos += 1
        elif pos in [19, 38, 57, 76, 95, 114, 133, 152, 171]: # Square 'L'
            if   d == '00': pos -= 19
            elif d == '01': pos -= 18
            elif d == '10': pos += 19
            else: pos += 20
        elif pos in [37, 56, 75, 94, 113, 132, 151, 170, 189]: # Square 'R'
            if   d == '00': pos -= 20
            elif d == '01': pos -= 19
            elif d == '10': pos += 18
            else: pos += 19
        elif pos == 0: # Square 'a'
            if   d == '01': pos += 1
            elif d == '10': pos += 19
            elif d == '11': pos += 20
        elif pos == 18: # Square 'b'
            if   d == '00': pos -= 1
            elif d == '10': pos += 18
            elif d == '11': pos += 19
        elif pos == 190: # Square 'c'
            if   d == '00': pos -= 19
            elif d == '01': pos -= 18
            elif d == '11': pos += 1
        else: # Square 'd'
            if   d == '00': pos -= 20
            elif d == '01': pos -= 19
            elif d == '10': pos -= 1
        walk.append(pos)

    for w in walk:
        visits[w] += 1
        if visits[w] > 18: visits[w] = 18

    # See https://tools.ietf.org/html/rfc4880#section-9.1
    # Also https://tools.ietf.org/html/rfc6637#section4
    if key_algo == '17':
        key_algo = 'DSA'
    elif key_algo == '1' or key_algo == '2' or key_algo == '3':
        key_algo = 'RSA'
    elif key_algo == '16' or key_algo == '20':
        key_algo = 'Elg'
    elif key_algo == '18':
        key_algo = 'ECDH'
    elif key_algo == '19':
        key_algo = 'ECDSA'
    elif key_algo == '21':
        key_algo = 'X9.42'
    else: key_algo = 'N/A'

    if len("["+key_algo+" "+key_size+"]") == 10:
        art += '+----[{0} {1}]-----+\n'.format(key_algo, key_size)
    elif len("["+key_algo+" "+key_size+"]") == 11:
        art += '+----[{0} {1}]----+\n'.format(key_algo, key_size)
    elif len("["+key_algo+" "+key_size+"]") == 9:
        art += '+-----[{0} {1}]-----+\n'.format(key_algo, key_size)
    elif len("["+key_algo+" "+key_size+"]") == 12:
        art += '+---[{0} {1}]----+\n'.format(key_algo, key_size)
    elif len("["+key_algo+" "+key_size+"]") == 13:
        art += '+---[{0} {1}]---+\n'.format(key_algo, key_size)
    elif len("["+key_algo+" "+key_size+"]") == 14:
        art += '+--[{0} {1}]---+\n'.format(key_algo, key_size)
    elif len("["+key_algo+" "+key_size+"]") == 15:
        art += '+--[{0} {1}]--+\n'.format(key_algo, key_size)
    elif len("["+key_algo+" "+key_size+"]") == 16:
        art += '+-[{0} {1}]--+\n'.format(key_algo, key_size)
    elif len("["+key_algo+" "+key_size+"]") == 17:
        art += '+-[{0} {1}]-+\n'.format(key_algo, key_size)
    else:
        art += '+-------------------+\n'

    for i, v in enumerate(visits):
        coin += coins[v]
        if i % 19 == 0:
            coin = "|%s" % coin
        #if i == 104:
        #    coin = "%s%s" % (coin[:10], markers[0])
        #if i == walk[len(walk)-1]:
        #    coin = "%s%s" % (coin[:len(coin)-1], markers[1])
        if i % 19 == 18:
            art += "%s|\n" % coin
            coin = ''

    art += '+----[{0}]-----+'.format(key_fpr[-8:])
    return art

key = args.file.name
print draw_art(key)
